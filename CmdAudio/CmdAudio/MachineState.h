#pragma once

#include <vector>
#include <map>
#include "BaseCounted.h"
#include "GeneratorArray.h"

///
/// MachineState
/// Class storing the current state of the 'machine'
///
class MachineState
{
public:
    typedef std::pair<BaseCountedPtr<GeneratorBase>, MachineState&> tMachineParameter;
public:
    MachineState(MachineState* pParent = nullptr);
    
    void Reset();
    void PushParameters( BaseCountedPtr<GeneratorArray>& parameters, MachineState& machine );
    void PopParameters();
    tMachineParameter Find( const std::string & name ) const;
    
    float GetSampleRate() const { return m_sampleRate; }

    template <class T>
    BaseCountedPtr<T> GetGeneratorState( int generatorId )
    {
        BaseCountedPtr<GeneratorStateBase> state = GetGeneratorState_(generatorId);
        if (!state)
        {
            state = new T( GenerateStateId() );
            m_states.insert( std::pair<int,BaseCountedPtr<GeneratorStateBase>>(generatorId, state) );
            fprintf(stdout, "not found gen %d\n", generatorId);
        }
        else
        {
            //            fprintf(stdout, "found gen %d\n", generatorId);
        }
        return state.StaticCast<T>();
    }
    template <class T, typename U>
    BaseCountedPtr<T> GetGeneratorState( int generatorId, U data )
    {
        BaseCountedPtr<GeneratorStateBase> state = GetGeneratorState_(generatorId);
        if (!state)
        {
            state = new T( GenerateStateId(), data );
            m_states.insert( std::pair<int,BaseCountedPtr<GeneratorStateBase>>(generatorId, state) );
            fprintf(stdout, "not found gen %d\n", generatorId);
        }
        else
        {
            //            fprintf(stdout, "found gen %d\n", generatorId);
        }
        return state.StaticCast<T>();
    }
    
    void RemoveGeneratorState( int id )
    {
        m_states.erase( id );
    }
    
    const SampleDataBuffer * GetGeneratorBuffer( int generatorId ) const;
    void SetGeneratorBuffer( int generatorId, BaseCountedPtr<SampleDataBuffer> );
    void ClearStatementBuffers();
    
private:
    BaseCountedPtr<GeneratorStateBase> GetGeneratorState_( int id ) const
    {
        auto stateIt = m_states.find(id);
        if (stateIt != m_states.end())
        {
            return stateIt->second;
        }
        return nullptr;
    }
    int GenerateStateId();
    
    typedef std::pair<BaseCountedPtr<GeneratorArray>, MachineState&> tMachineParameterGroup;    // parameters and the machinestate they are associated with
    std::vector< tMachineParameterGroup > m_parameterStack;
    MachineState*       m_parent;
    float               m_sampleRate;
    int                 m_nextStateId;
    
    // State data for each generator (stored so generators can have history over time)
    typedef std::map<int,BaseCountedPtr<GeneratorStateBase>> tStateMap;
    tStateMap           m_states;
    
    // Buffers generated by statements (cleared everytime we generate a new set of samples)
    typedef std::map<int,BaseCountedPtr<SampleDataBuffer>> tStatementMap;
    tStatementMap       m_statementBuffers;
};
